# Starting
	In starting, there are some fundamentals of programming. Not going on it.

## Assembly language-
`Assembly language is a low level language. It is used to understand the source which is used by programmers to understand what machine is understanding.`

There are mainly two types of syntax for assembly language-
* AT&T syntax
* intel syntax

### AT&T syntax -
It is used in most **\*nix** systems. Uses **$** and **%**. It is not so readable. So, it is not used mostly.

### intel syntax -
It is in more readable format. Doesn't uses any special symbol as prefix.

	eg.,
---
```bash
	$ objdump -D a.out | grep -A20 main.:
```
```bash
	$ objdump -M intel -D a.out | grep -A20 main.:
```
---

## Registers -
	Programs have their own set of special variables called registers.

#### Note 1 ->
	Processors uses binary languages, which is not so useful for us.
	Machine language use hex code as code which is still not useful for us.
	So, we use assembly language which is more readable.
#### Note 2 ->
	The 8086 was first x86 processor, then came 80186,80286...,80486 which are of same family.

## Debuggers -
Debuggers are used to step through program, examine and view processor registers. It can view execution from all registers. It can view execution from all angles, pause it and change anything along the way.

**GNU** includes _gdb_ as debugger. E.g.,

---
```bash
	$ gdb -q ./a.out
```
	Some registers we got in it are-

These four are gen. purpose registers used as temporary variables in CPU when executing machine information.

* **e/rax** = accumulator

* **e/rbx** = base

* **e/rcx** = counter

* **e/rdx** = data

These two are known as pointer or indexes.

* **e/rsp** = stack pointer

* **e/rbp** = base pointer

* **e/rsi** = source index

* **e/rdi** = destination index

Now, here are some other registers.

* **e/rip** = Instruction pointer register points to the current location to what the processor is reading.

* **eflags** = This register consists of several bit flags that are used for comparision and memory argumentation.

## Settings for assembly language in gdb -

These are the following steps to set intel syntax in gdb.

```bash
	$ gdb -q
	(gdb) set dis intel
	(gdb) quit
	$ echo "set dis intel" > ~/.gdbinit
	$ cat ~/.gdbinit
	set dis intel
```
 Following is the intel syntax style-

	operation \<destionation>, \<source>

Here, is the meaning of displayed registers from debuggers.

<!--- Tables -->

|address|value|operation|registers|
|-------|-----|---------|---------|
|8048375|89 e5|mov|ebp,esp|
|8048377|83 ec 08|sub|esp,0x8|

The instructions above will move the value from esp to ebp and then subtract 8 from esp(storing the result in esp).

Here are the **mnemonics** and related **operations**-

|Mnemonics|operation|
|---------|---------|
| add | move |
| inc | increment |
| sub | substract |
| jle | jump if less than equal to  |
| jmp | jump |
| cmp | compare  |


|address|value|operation|registers|
|-------|-----|---------|---------|
|804838b|83 7d fc 09|cmp|DWORD PTR [ebp-4],0x9|

In this above example EBP minus 4 is compared to value 9

Let's use the debugger to step through the first program at assembly instruction level.
The -g flag used here can be used by GCC compiler to include extra debugging information, which will give GDB access to source code.

```bash
	$ gcc -g firstprog.c
	$ ls -l a.out
	<!--- output values --->

	$ gdb -q ./a.out
	(gdb) list
```
```c
		# include<stdio.h>

		int main(){
			int i;
			for (i=0;i<10;i++){
				printf("\nHello, world");
			}
			return 0;
		}
```
```bash
	(gdb) disassamble main
	Dump of assembler code for function main():
	# some dumps...
	End of assembler dump,
	(gdb) break main
	Breakpoint 1 at ..., line 6.
	(gdb) run
	Starting Program: /hacking/a.out

	Breakpoint 1, main() at firstprog.c:6
	6	for(i=0;i<10;i++)
	(gdb) info registers eip
	# you can also use i r eip as acronym type
	# some informations
	(gdb)
```
`Since, the breakpoint is set at the start of the function main(), it pauses just before the execution of any instruction in main(). Then the value of eip is displayed.`

Here, see that eip points to an instruction in the main() function's disassambly. The instructions before this are called **function prologue** and are generated by compilers to set up the memory for the rest of the main() function's local variables.

`The GDB debugger provides a direct method to examine memory, using the command 'x' short for examine.`

Some comman format letters for display-format to exmaine memory-address are as follow-

* **o**	= Display in octal
* **x** = Display in hexadecimal
* **t** = Display in binary
* **u** = Display unsigned decimal base-10 integer

	In the following example current address of eip is used

```bash
	(gdb) i r eip
	eip		0x8048384	0x8048384 <main+16>
	(gdb) x/o 0x8048384
	0x8048384 <main+16>:	077042707
	(gdb) x/x $eip
	0x8048384 <main+16>:	0x00fc45c7
	(gdb) x/u $eip
	0x8048384 <main+16>:	16532935
	(gdb) x/t $eip
	0x8048384 <main+16>:	0000000011111100010111000111
	(gdb)
```
The memory the eip register is pointing to can be examined by using the address stored in eip. The debugger lets you reference registers directly. So, the value of **$eip** is equal to the value **eip** contains at that moment.

***See how I'm taking notes and seeing live preview in browser.***

	I can also convert these to html and in pdf

